-- IndicatorController.lua
-- Stacking damage/heal indicator system with optimized billboard reusage

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local ConnectionManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/Kaic-dev/Brazil-Hub/main/ConnectionManager"))()

local Indicator = {}
Indicator.__index = Indicator

-- Configuration
local CONFIG = {
    STACK_INTERVAL = 1.0, -- Stack damage/regen every 1 second
    MIN_DAMAGE_SHOW = 0.1,
    MIN_REGEN_SHOW = 0.05,
    INDICATOR_LIFETIME = 2.5,
    REGEN_THRESHOLD = 0.6,
}

function Indicator.new()
    local self = setmetatable({}, Indicator)
    self.connMgr = ConnectionManager.new()
    self.monitoring = false
    self.playerStacks = {}
    return self
end

function Indicator:_getIndicatorPosition(character)
    return character:FindFirstChild("Torso") or character:FindFirstChild("UpperTorso")
        or character:FindFirstChild("Head") or character:FindFirstChild("HumanoidRootPart")
end

-- Reusable indicator (no spam)
function Indicator:_updateOrCreateIndicator(character, totalAmount, isDamage, isRegen)
    local attachPart = self:_getIndicatorPosition(character)
    if not attachPart then return end

    local indicatorName
    if isDamage then
        indicatorName = "DamageIndicator"
    elseif isRegen then
        indicatorName = "RegenIndicator"
    else
        indicatorName = "HealIndicator"
    end

    local billboard = attachPart:FindFirstChild(indicatorName)
    local label

    if billboard and billboard:IsA("BillboardGui") then
        label = billboard:FindFirstChild("TextLabel")
    else
        billboard = Instance.new("BillboardGui")
        billboard.Name = indicatorName
        billboard.Adornee = attachPart
        billboard.Size = UDim2.new(0, 200, 0, 80)
        billboard.AlwaysOnTop = true
        billboard.LightInfluence = 0
        billboard.StudsOffset = Vector3.new(math.random(-30, 30) / 10, math.random(15, 35) / 10, math.random(-20, 20) / 10)
        billboard.Parent = attachPart

        label = Instance.new("TextLabel")
        label.Size = UDim2.new(1, 0, 1, 0)
        label.BackgroundTransparency = 1
        label.Font = Enum.Font.GothamBold
        label.TextStrokeTransparency = 0
        label.TextStrokeColor3 = Color3.new(0, 0, 0)
        label.Parent = billboard
    end

    local text, color
    if isDamage then
        text = string.format("-%d", math.floor(totalAmount + 0.5))
        color = Color3.fromRGB(255, 60, 60)
        label.TextSize = 32
    elseif isRegen then
        text = string.format("+%d", math.floor(totalAmount + 0.5))
        color = Color3.fromRGB(85, 255, 255)
        label.TextSize = 24
    else
        text = string.format("+%d", math.floor(totalAmount + 0.5))
        color = Color3.fromRGB(85, 255, 85)
        label.TextSize = 28
    end

    label.Text = text
    label.TextColor3 = color

    if billboard:FindFirstChild("FadeTask") then
        billboard.FadeTask:Destroy()
    end

    local fadeMarker = Instance.new("ObjectValue")
    fadeMarker.Name = "FadeTask"
    fadeMarker.Parent = billboard

    task.spawn(function()
        task.wait(CONFIG.INDICATOR_LIFETIME)
        if billboard and billboard.Parent then
            billboard:Destroy()
        end
    end)
end

function Indicator:_initializePlayerStack(playerKey)
    self.playerStacks[playerKey] = {
        damageStack = 0,
        healStack = 0,
        regenStack = 0,
        lastStackTime = tick(),
        lastHealth = 0,
        stackTimer = nil
    }
end

function Indicator:_processStacks(player, character, playerKey)
    local stack = self.playerStacks[playerKey]
    if not stack then return end

    local currentTime = tick()

    if stack.damageStack >= CONFIG.MIN_DAMAGE_SHOW then
        self:_updateOrCreateIndicator(character, stack.damageStack, true, false)
    end

    if stack.healStack >= CONFIG.MIN_REGEN_SHOW then
        self:_updateOrCreateIndicator(character, stack.healStack, false, false)
    end

    if stack.regenStack >= CONFIG.MIN_REGEN_SHOW then
        self:_updateOrCreateIndicator(character, stack.regenStack, false, true)
    end

    stack.damageStack = 0
    stack.healStack = 0
    stack.regenStack = 0
    stack.lastStackTime = currentTime
end

function Indicator:_trackPlayerHealth(player, character)
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end

    local playerKey = tostring(player.UserId)
    self:_initializePlayerStack(playerKey)
    local stack = self.playerStacks[playerKey]
    stack.lastHealth = humanoid.Health

    local function startStackTimer()
        if stack.stackTimer then
            stack.stackTimer:Disconnect()
        end

        stack.stackTimer = task.spawn(function()
            while self.monitoring and character.Parent and humanoid.Parent do
                task.wait(CONFIG.STACK_INTERVAL)
                if self.monitoring and character.Parent then
                    self:_processStacks(player, character, playerKey)
                end
            end
        end)
    end

    startStackTimer()

    local healthConnection = humanoid.HealthChanged:Connect(function(newHealth)
        if not self.monitoring or not stack then return end

        local deltaHealth = newHealth - stack.lastHealth
        local absChange = math.abs(deltaHealth)

        if absChange > 0.01 then
            if deltaHealth < 0 then
                stack.damageStack = stack.damageStack + absChange
            elseif deltaHealth > 0 then
                if absChange <= CONFIG.REGEN_THRESHOLD then
                    stack.regenStack = stack.regenStack + absChange
                else
                    stack.healStack = stack.healStack + absChange
                end
            end
        end

        stack.lastHealth = newHealth
    end)

    self.connMgr:add(healthConnection)

    local cleanupConnection
    cleanupConnection = character.AncestryChanged:Connect(function()
        if not character.Parent then
            if stack.stackTimer then
                stack.stackTimer:Disconnect()
                stack.stackTimer = nil
            end
            self.playerStacks[playerKey] = nil
            cleanupConnection:Disconnect()
        end
    end)

    self.connMgr:add(cleanupConnection)

    local tag = Instance.new("BoolValue")
    tag.Name = "_IndicatorTag"
    tag.Parent = humanoid
end

-- Manual (instant) indicators
function Indicator:showDamage(character, amount)
    if amount <= 0 then return end
    return self:_updateOrCreateIndicator(character, amount, true, false)
end

function Indicator:showHeal(character, amount)
    if amount <= 0 then return end
    return self:_updateOrCreateIndicator(character, amount, false, false)
end

function Indicator:showRegen(character, amount)
    if amount <= 0 then return end
    return self:_updateOrCreateIndicator(character, amount, false, true)
end

function Indicator:clear(character)
    if not character then return end
    for _, descendant in ipairs(character:GetDescendants()) do
        if descendant:IsA("BillboardGui") and (descendant.Name == "DamageIndicator" or descendant.Name == "HealIndicator" or descendant.Name == "RegenIndicator") then
            descendant:Destroy()
        end
    end
end

function Indicator:enable()
    if self.monitoring then return end
    self.monitoring = true
    self:_setupMonitoring()
end

function Indicator:disable()
    self.monitoring = false
    self.connMgr:disconnectAll()

    for _, stack in pairs(self.playerStacks) do
        if stack.stackTimer then
            stack.stackTimer:Disconnect()
        end
    end

    self.playerStacks = {}

    for _, player in ipairs(Players:GetPlayers()) do
        if player.Character then
            local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                local tag = humanoid:FindFirstChild("_IndicatorTag")
                if tag then tag:Destroy() end
            end
        end
    end
end

function Indicator:_setupMonitoring()
    local function connectCharacter(player, character)
        if not character then return end

        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if not humanoid or humanoid:FindFirstChild("_IndicatorTag") then return end

        task.wait(0.5)

        if humanoid.Parent and self.monitoring then
            self:_trackPlayerHealth(player, character)
        end
    end

    for _, player in ipairs(Players:GetPlayers()) do
        if player.Character then
            task.spawn(function()
                connectCharacter(player, player.Character)
            end)
        end

        self.connMgr:add(player.CharacterAdded:Connect(function(character)
            task.spawn(function()
                connectCharacter(player, character)
            end)
        end))
    end

    self.connMgr:add(Players.PlayerAdded:Connect(function(player)
        if player.Character then
            task.spawn(function()
                connectCharacter(player, player.Character)
            end)
        end

        self.connMgr:add(player.CharacterAdded:Connect(function(character)
            task.spawn(function()
                connectCharacter(player, character)
            end)
        end))
    end))

    self.connMgr:add(Players.PlayerRemoving:Connect(function(player)
        local playerKey = tostring(player.UserId)
        local stack = self.playerStacks[playerKey]
        if stack and stack.stackTimer then
            stack.stackTimer:Disconnect()
        end
        self.playerStacks[playerKey] = nil
    end))
end

return Indicator
