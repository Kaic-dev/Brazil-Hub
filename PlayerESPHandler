-- PlayerESP Otimizado para Performance Máxima
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local Utils = loadstring(game:HttpGet("https://raw.githubusercontent.com/Kaic-dev/Brazil-Hub/refs/heads/main/Utils"))()
local utils = Utils.new()
local ConnectionManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/Kaic-dev/Brazil-Hub/main/ConnectionManager"))()

-- Cache global de objetos pesados
local LocalPlayer = Players.LocalPlayer
local floor = math.floor
local format = string.format
local tick = tick
local pairs = pairs
local ipairs = ipairs

-- Cache de funções Roblox para evitar indexação repetida
local newInstance = Instance.new
local findFirstChild = game.FindFirstChild
local getChildren = game.GetChildren

-- Constantes para otimização
local UPDATE_INTERVAL = 0.5 -- Intervalo de atualização dos billboards
local DATA_CACHE_INTERVAL = 1.0 -- Intervalo de cache de dados dos players
local DISTANCE_UPDATE_INTERVAL = 0.25 -- Intervalo específico para atualização de distância

-- Pool de objetos reutilizáveis
local stringPool = {}
local function getPooledString(template, ...)
    local key = template .. tostring(...)
    if not stringPool[key] then
        stringPool[key] = format(template, ...)
    end
    return stringPool[key]
end

-- Função otimizada para encontrar adornee
local function getBestAdornee(character)
    return character:FindFirstChild("Head") or 
           character:FindFirstChild("UpperTorso") or 
           character:FindFirstChild("Torso") or 
           character:FindFirstChildWhichIsA("BasePart")
end

local PlayerESP = {}
PlayerESP.__index = PlayerESP

function PlayerESP.new()
    local self = setmetatable({}, PlayerESP)
    self.enabled = false
    self._connMgr = ConnectionManager.new()
    self._playerConnMgrs = {}
    self.espBillboards = {}
    self.dataCache = {}
    
    -- Cache de configuração com valores padrão
    self.displayConfig = {
        showPlayerName = true,
        showRogueName = true,
        showEdict = true,
        showHealth = true,
        showHealthPercent = true,
        showDistance = true
    }
    
    -- Timestamps otimizados para diferentes tipos de atualização
    self._lastBillboardUpdate = 0
    self._lastDistanceUpdate = 0
    
    -- Cache de caracteres locais para evitar múltiplas consultas
    self._localCharCache = nil
    self._localCharCacheTime = 0
    
    return self
end

-- Cache otimizado para character local
function PlayerESP:getLocalCharacter()
    local currentTime = tick()
    if currentTime - self._localCharCacheTime > 1 then
        self._localCharCache = LocalPlayer and LocalPlayer.Character
        self._localCharCacheTime = currentTime
    end
    return self._localCharCache
end

function PlayerESP:createBillboard(player)
    local character = player.Character
    if not character or character:FindFirstChild("PlayerESP") then return end
    
    local adornee = getBestAdornee(character)
    if not adornee then return end

    -- Criação otimizada do billboard com propriedades em lote
    local billboard = newInstance("BillboardGui")
    billboard.Name = "PlayerESP"
    billboard.LightInfluence = 1
    billboard.Active = true
    billboard.Adornee = adornee
    billboard.ClipsDescendants = true
    billboard.AlwaysOnTop = true
    billboard.Size = UDim2.new(0, 500, 0, 100)
    billboard.Parent = adornee

    -- Layout principal
    local layout = newInstance("UIListLayout")
    layout.Padding = UDim.new(0, 3)
    layout.SortOrder = Enum.SortOrder.LayoutOrder
    layout.Parent = billboard

    -- Função helper para criar labels de forma otimizada
    local function createLabel(text, parent)
        local label = newInstance("TextLabel")
        label.FontSize = Enum.FontSize.Size14
        label.TextColor3 = Color3.new(1, 1, 1)
        label.Text = text
        label.TextStrokeTransparency = 0.5
        label.Font = Enum.Font.SourceSansSemibold
        label.BackgroundTransparency = 1
        label.TextSize = 14
        label.Size = UDim2.new(0, 0, 0.1, 0)
        label.AutomaticSize = Enum.AutomaticSize.X
        label.TextXAlignment = Enum.TextXAlignment.Center
        label.Parent = parent
        return label
    end

    -- Criação otimizada dos frames e labels
    local nameFrame = newInstance("Frame")
    nameFrame.BackgroundTransparency = 1
    nameFrame.Size = UDim2.new(1, 0, 0.1, 0)
    nameFrame.Parent = billboard

    local nameLabel = createLabel("[" .. player.Name .. "]", nameFrame)
    local distanceLabel = createLabel("[0m]", nameFrame)

    local nameLayout = newInstance("UIListLayout")
    nameLayout.FillDirection = Enum.FillDirection.Horizontal
    nameLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
    nameLayout.VerticalAlignment = Enum.VerticalAlignment.Center
    nameLayout.SortOrder = Enum.SortOrder.LayoutOrder
    nameLayout.Parent = nameFrame

    local infoFrame = newInstance("Frame")
    infoFrame.BackgroundTransparency = 1
    infoFrame.Size = UDim2.new(1, 0, 0.1, 0)
    infoFrame.Parent = billboard

    local infoLayout = newInstance("UIListLayout")
    infoLayout.VerticalAlignment = Enum.VerticalAlignment.Center
    infoLayout.FillDirection = Enum.FillDirection.Horizontal
    infoLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
    infoLayout.SortOrder = Enum.SortOrder.LayoutOrder
    infoLayout.Parent = infoFrame

    local rogueLabel = createLabel("[Lord Abadon Terrified]", infoFrame)
    local edictLabel = createLabel("[Healer]", infoFrame)

    local hpFrame = newInstance("Frame")
    hpFrame.BackgroundTransparency = 1
    hpFrame.Size = UDim2.new(1, 0, 0.1, 0)
    hpFrame.Parent = billboard

    local hpLayout = newInstance("UIListLayout")
    hpLayout.VerticalAlignment = Enum.VerticalAlignment.Center
    hpLayout.FillDirection = Enum.FillDirection.Horizontal
    hpLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
    hpLayout.SortOrder = Enum.SortOrder.LayoutOrder
    hpLayout.Parent = hpFrame

    local hpLabel = createLabel("[100/100]", hpFrame)
    local hpPercLabel = createLabel("[100%]", hpFrame)

    -- Cache otimizado dos objetos
    self.espBillboards[player] = {
        billboard = billboard,
        nameLabel = nameLabel,
        distanceLabel = distanceLabel,
        rogueLabel = rogueLabel,
        edictLabel = edictLabel,
        hpLabel = hpLabel,
        hpPercLabel = hpPercLabel,
        infoFrame = infoFrame,
        hpFrame = hpFrame,
        nameFrame = nameFrame,
        -- Cache de character para evitar múltiplas consultas
        cachedCharacter = character,
        characterCacheTime = tick()
    }
    
    -- Cache de dados com valores padrão
    self.dataCache[player] = {
        lastUpdate = 0,
        rogueName = "",
        edict = "",
        healthDisplay = "",
        healthPercentDisplay = "",
        lastDistance = 0,
        lastDistanceUpdate = 0
    }
    
    self:setDisplayConfig(self.displayConfig)
    self:updatePlayerData(player)
end

function PlayerESP:removeBillboard(player)
    local data = self.espBillboards[player]
    if data and data.billboard then
        data.billboard:Destroy()
        self.espBillboards[player] = nil
    end
    self.dataCache[player] = nil
end

-- Função otimizada para atualizar dados dos players
function PlayerESP:updatePlayerData(player)
    if not player or not player.Parent then return end
    
    local cache = self.dataCache[player]
    if not cache then return end
    
    local currentTime = tick()
    
    -- Throttling para dados pesados (rogue, edict, health)
    if currentTime - cache.lastUpdate >= DATA_CACHE_INTERVAL then
        cache.rogueName = utils:getPlayerRogueDisplay(player)
        cache.edict = utils:getPlayerEdictDisplay(player)
        cache.healthDisplay, cache.healthPercentDisplay = utils:getPlayerHealthDisplay(player)
        cache.lastUpdate = currentTime
    end
    
    local data = self.espBillboards[player]
    if not data then return end
    
    -- Atualização dos textos apenas se necessário
    data.nameLabel.Text = "[" .. player.Name .. "]"
    data.rogueLabel.Text = "[" .. cache.rogueName .. "]"
    data.edictLabel.Text = "[" .. cache.edict .. "]"
    data.hpLabel.Text = "[" .. cache.healthDisplay .. "]"
    data.hpPercLabel.Text = "[" .. cache.healthPercentDisplay .. "]"
    
    -- Atualização de distância com throttling separado
    if currentTime - cache.lastDistanceUpdate >= DISTANCE_UPDATE_INTERVAL then
        self:updateDistance(player, data, cache, currentTime)
    end
end

-- Função separada para atualização de distância (otimizada)
function PlayerESP:updateDistance(player, data, cache, currentTime)
    local localChar = self:getLocalCharacter()
    local targetChar = player.Character
    
    if localChar and targetChar then
        local localRoot = localChar:FindFirstChild("HumanoidRootPart")
        local targetRoot = targetChar:FindFirstChild("HumanoidRootPart")
        
        if localRoot and targetRoot then
            local dist = (localRoot.Position - targetRoot.Position).Magnitude
            local distanceInt = floor(dist)
            
            -- Só atualiza se a distância mudou significativamente
            if distanceInt ~= cache.lastDistance then
                data.distanceLabel.Text = getPooledString("[%dm]", distanceInt)
                cache.lastDistance = distanceInt
            end
        else
            data.distanceLabel.Text = "[0m]"
            cache.lastDistance = 0
        end
    end
    
    cache.lastDistanceUpdate = currentTime
end

-- Função otimizada para atualizar billboards
function PlayerESP:updateBillboards()
    local currentTime = tick()
    if currentTime - self._lastBillboardUpdate < UPDATE_INTERVAL then return end
    self._lastBillboardUpdate = currentTime
    
    -- Lista de players a serem removidos (para evitar modificação durante iteração)
    local toRemove = {}
    
    for player, data in pairs(self.espBillboards) do
        if player and player.Parent and player.Character then
            self:updatePlayerData(player)
        else
            toRemove[#toRemove + 1] = player
        end
    end
    
    -- Remove players inválidos
    for i = 1, #toRemove do
        self:removeBillboard(toRemove[i])
    end
end

function PlayerESP:connectPlayer(player)
    if player == LocalPlayer then return end
    
    local mgr = self._playerConnMgrs[player]
    if mgr then mgr:disconnectAll() end
    
    mgr = ConnectionManager.new()
    self._playerConnMgrs[player] = mgr
    
    mgr:add(player.CharacterAdded:Connect(function(character)
        if self.enabled then
            -- Pequeno delay para garantir que o character esteja totalmente carregado
            task.wait(0.1)
            self:createBillboard(player)
        end
    end))
    
    mgr:add(player.CharacterRemoving:Connect(function(character)
        self:removeBillboard(player)
    end))
    
    if player.Character then
        self:createBillboard(player)
    end
end

function PlayerESP:enable()
    self.enabled = true
    self:cleanup()
    
    -- Conecta players existentes
    local playerList = Players:GetPlayers()
    for i = 1, #playerList do
        self:connectPlayer(playerList[i])
    end
    
    self._connMgr:add(Players.PlayerAdded:Connect(function(player)
        self:connectPlayer(player)
    end))
    
    self._connMgr:add(Players.PlayerRemoving:Connect(function(player)
        self:removeBillboard(player)
        local mgr = self._playerConnMgrs[player]
        if mgr then
            mgr:disconnectAll()
            self._playerConnMgrs[player] = nil
        end
    end))
    
    -- Usa Heartbeat com throttling interno otimizado
    self._connMgr:add(RunService.Heartbeat:Connect(function()
        self:updateBillboards()
    end))
end

function PlayerESP:disable()
    self.enabled = false
    self:cleanup()
end

function PlayerESP:cleanup()
    self._connMgr:disconnectAll()
    for _, mgr in pairs(self._playerConnMgrs) do
        mgr:disconnectAll()
    end
    self._playerConnMgrs = {}
    for player, _ in pairs(self.espBillboards) do
        self:removeBillboard(player)
    end
    self.dataCache = {}
    -- Limpa cache local
    self._localCharCache = nil
    self._localCharCacheTime = 0
end

-- Funções de configuração otimizadas
function PlayerESP:setTextSize(size)
    for _, data in pairs(self.espBillboards) do
        data.nameLabel.TextSize = size
        data.rogueLabel.TextSize = size
        data.edictLabel.TextSize = size
        data.hpLabel.TextSize = size
        data.hpPercLabel.TextSize = size
        data.distanceLabel.TextSize = size
    end
end

function PlayerESP:setTextColor(color)
    for _, data in pairs(self.espBillboards) do
        data.nameLabel.TextColor3 = color
        data.rogueLabel.TextColor3 = color
        data.edictLabel.TextColor3 = color
        data.hpLabel.TextColor3 = color
        data.hpPercLabel.TextColor3 = color
        data.distanceLabel.TextColor3 = color
    end
end

function PlayerESP:setDisplayConfig(config)
    self.displayConfig = config or self.displayConfig
    
    for _, data in pairs(self.espBillboards) do
        -- Configuração otimizada com menos loops
        local frameConfigs = {
            {
                frame = data.nameFrame,
                labels = {
                    {label = data.nameLabel, show = self.displayConfig.showPlayerName},
                    {label = data.distanceLabel, show = self.displayConfig.showDistance}
                }
            },
            {
                frame = data.infoFrame,
                labels = {
                    {label = data.rogueLabel, show = self.displayConfig.showRogueName},
                    {label = data.edictLabel, show = self.displayConfig.showEdict}
                }
            },
            {
                frame = data.hpFrame,
                labels = {
                    {label = data.hpLabel, show = self.displayConfig.showHealth},
                    {label = data.hpPercLabel, show = self.displayConfig.showHealthPercent}
                }
            }
        }
        
        for i = 1, #frameConfigs do
            local frameConfig = frameConfigs[i]
            local frame = frameConfig.frame
            local hasContent = false
            
            -- Remove apenas elementos não-layout
            local children = frame:GetChildren()
            for j = 1, #children do
                local child = children[j]
                if not child:IsA("UIListLayout") then
                    child.Parent = nil
                end
            end
            
            -- Adiciona labels visíveis
            local labels = frameConfig.labels
            for j = 1, #labels do
                local labelConfig = labels[j]
                if labelConfig.show ~= false and labelConfig.label then
                    labelConfig.label.Parent = frame
                    hasContent = true
                end
            end
            
            frame.LayoutOrder = i
            frame.Parent = hasContent and data.billboard or nil
        end
    end
end

return PlayerESP
