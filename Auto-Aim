-- autoaim.lua
-- Handler OOP de Auto-Aim para integração com toggle externo
-- Uso: local AutoAim = require(path); local autoAim = AutoAim.new(); autoAim:enable()/autoAim:disable()

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local Debris = game:GetService("Debris")

local LIVE_FOLDER = Workspace:WaitForChild("Live")
local MAX_RANGE = 200

local AutoAim = {}
AutoAim.__index = AutoAim

--- Cria uma nova instância do AutoAim
function AutoAim.new()
    local self = setmetatable({}, AutoAim)
    self.enabled = false
    self.maxRange = 200
    self.timeToHit = 0.15
    self.toolNames = { ["Fimbulvetr"] = false, ["Perflora"] = false, ["Armis"] = false, ["Grapple"] = false, ['Percutiens'] = false }
    self.studsBehindMin = 20
    self.studsBehindMax = 30
    return self
end

--- Define o alcance máximo do auto-aim
function AutoAim:setRange(range)
    self.maxRange = range
end

--- Define o tempo de previsão do auto-aim
function AutoAim:setTimeToHit(time)
    self.timeToHit = time
end

--- Define as ferramentas que ativam o auto-aim
function AutoAim:setTools(toolTable)
    -- Aceita tanto array (lista) quanto dicionário
    local hash = {}
    if type(toolTable) == "table" then
        local isArray = false
        local count = 0
        for k, v in pairs(toolTable) do
            count = count + 1
            if type(k) == "number" then isArray = true end
        end
        if isArray then
            -- Array: converte para hash
            for _, tool in ipairs(toolTable) do
                hash[tool] = true
            end
        else
            -- Já é hash
            hash = toolTable
        end
    end
    self.toolNames = hash
end

function AutoAim:getBestNPC(localChar)
    -- Verifica se o personagem local é válido
    if not localChar or not localChar:FindFirstChild("HumanoidRootPart") then return end

    -- Obtém a câmera e a posição do mouse
    local camera = Workspace.CurrentCamera
    local mouse = Players.LocalPlayer:GetMouse()
    local mousePos = Vector2.new(mouse.X, mouse.Y)
    local fovMax = self.fovMax or 20

    -- Precomputa o cosseno do ângulo máximo do FOV
    local cosFov = math.cos(math.rad(fovMax / 2))

    -- Calcula a direção do mouse
    local mouseRay = camera:ScreenPointToRay(mouse.X, mouse.Y)
    local mouseDir = mouseRay.Direction.Unit

    -- Inicializa variáveis para rastrear o melhor NPC
    local closestNPC, maxDot = nil, -1

    -- Itera sobre os modelos em LIVE_FOLDER
    for _, model in ipairs(LIVE_FOLDER:GetChildren()) do
        local hrp = model:FindFirstChild("HumanoidRootPart")
        local head = model:FindFirstChild("Head")
        local knocked = model:FindFirstChild("Knocked")
        local enoughHealth = model:FindFirstChild("Humanoid") and model.Humanoid.Health > 5

        -- Aplica filtros para NPCs válidos
        if model:IsA("Model") and model ~= localChar and hrp and head and not knocked and enoughHealth then
            local npcScreenPos, onScreen = camera:WorldToViewportPoint(head.Position)
            if onScreen then
                -- Calcula a direção do NPC e o produto escalar
                local npcDir = (head.Position - camera.CFrame.Position).Unit
                local dot = mouseDir:Dot(npcDir)

                -- Verifica se está dentro do FOV e é o melhor candidato
                if dot >= cosFov and dot > maxDot then
                    maxDot = dot
                    closestNPC = model
                end
            end
        end
    end

    -- Exibe o resultado
    if closestNPC then
        print("[AutoAim] NPC escolhido:", closestNPC.Name)
    else
        print("[AutoAim] Nenhum NPC dentro do FOV!")
    end

    return closestNPC
end

--- Ativa o auto-aim (substitui RemoteFunction.OnClientInvoke)
function AutoAim:enable()
    if self.enabled then return end
    self.enabled = true
    local LocalPlayer = Players.LocalPlayer or Players.PlayerAdded:Wait()
    local Mouse = LocalPlayer:GetMouse()
    local RemoteFunction = ReplicatedStorage:WaitForChild("Requests"):WaitForChild("GetMouse")
    RemoteFunction.OnClientInvoke = function()
        local character = LocalPlayer.Character
        if not character then return end

        local equippedTool = character:FindFirstChildOfClass("Tool")
        if equippedTool then
            print("Equipped Tool:", equippedTool.Name)
        end

        local areaMarkers = Workspace:FindFirstChild("AreaMarkers")
        if areaMarkers then
            Mouse.TargetFilter = areaMarkers:FindFirstChild("The Arena")
        end

        if equippedTool and self.toolNames[equippedTool.Name] then
            local targetNPC = self:getBestNPC(character)
            if targetNPC and targetNPC:FindFirstChild("HumanoidRootPart") then
                local npcHRP = targetNPC.HumanoidRootPart
                local npcHead = targetNPC:FindFirstChild("Head")
                if npcHead then
                    local hitPosition
                    if equippedTool.Name == "Percutiens" then
                        -- Mira atrás do NPC em relação ao jogador, usando range configurável
                        local direction = (npcHRP.Position - character.HumanoidRootPart.Position).Unit
                        local distanceBehind = math.random(self.studsBehindMin, self.studsBehindMax)
                        hitPosition = npcHead.Position + direction * distanceBehind
                    else
                        -- Mira normal (predição)
                        local velocity = npcHRP.Velocity
                        local timeToHit = self.timeToHit or 0.15
                        local predictedPos = npcHead.Position + velocity * timeToHit
                        hitPosition = predictedPos + Vector3.new(0, -2, 0)
                    end

                    local marker = Instance.new("Part")
                    marker.Anchored = true
                    marker.CanCollide = false
                    marker.Size = Vector3.new(0.5, 0.5, 0.5)
                    marker.Color = Color3.new(0, 1, 0)
                    marker.Material = Enum.Material.Neon
                    marker.Position = hitPosition
                    marker.Parent = Workspace
                    Debris:AddItem(marker, 2)

                    return {
                        Hit = CFrame.new(hitPosition),
                        Target = targetNPC,
                        UnitRay = Mouse.UnitRay,
                        X = Mouse.X,
                        Y = Mouse.Y
                    }
                end
            end
        end

        return {
            Hit = Mouse.Hit,
            Target = Mouse.Target,
            UnitRay = Mouse.UnitRay,
            X = Mouse.X,
            Y = Mouse.Y
        }
    end
end

--- Desativa o auto-aim (restaura RemoteFunction.OnClientInvoke)
function AutoAim:disable()
    if not self.enabled then return end
    self.enabled = false
    local RemoteFunction = ReplicatedStorage:WaitForChild("Requests"):WaitForChild("GetMouse")
    RemoteFunction.OnClientInvoke = nil
end

-- Adicionar setter para FOV
function AutoAim:setFOV(fov)
    self.fovMax = fov
end

function AutoAim:setStudsBehindRange(min, max)
    self.studsBehindMin = min
    self.studsBehindMax = max
end

return AutoAim 
