-- trinket_esp_handler.lua
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")

local TrinketESP = {}
TrinketESP.__index = TrinketESP

TrinketESP.defaultTextSize = 14
TrinketESP.defaultTextColor = Color3.fromRGB(255, 255, 0)
TrinketESP.enabled = false

local ConnectionManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/Kaic-dev/Brazil-Hub/main/ConnectionManager"))()

TrinketESP._trinketConnMgrs = {}

-- Tabela de MeshIds conhecidos para identificação de trinkets
local MESH_ID_MAP = {
    ["rbxassetid://5196551436"] = "Amulet",
    ["rbxassetid://5196577540"] = "Old Amulet",
    ["rbxassetid://5204003946"] = "Goblet",
    ["rbxassetid://5196782997"] = "Old Ring",
    ["rbxassetid://5196776695"] = "Ring",
    ["rbxassetid://5204453430"] = "Scroll",
    ["rbxassetid://2877143560"] = "Ruby",
    ["rbxassetid://2877143592"] = "Sapphire",
    ["rbxassetid://2877143624"] = "Emerald",
    ["rbxassetid://2520762076"] = "Howler Friend"
    -- Adicione outros MeshIds conforme necessário
}

-- Lista de matchers para trinkets especiais identificados por propriedades
local SPECIAL_TRINKET_MATCHERS = {
    function(part)
        -- Idol of the Forgotten
        if not part:IsA("UnionOperation") then return nil end
        if tostring(part.Color) ~= tostring(Color3.new(37/85,113/255,25/51)) then return nil end
        if part.Material ~= Enum.Material.Slate then return nil end
        local size = part.Size
        if math.abs(size.X - 0.7009) > 0.01 or math.abs(size.Y - 0.6554) > 0.01 or math.abs(size.Z - 0.6830) > 0.01 then
            return nil
        end
        local clickPart = part:FindFirstChildOfClass("Part")
        if not (clickPart and clickPart.Transparency == 1) then return nil end
        for _, child in ipairs(part:GetChildren()) do
            if child:IsA("ParticleEmitter") then
                return "Idol of the Forgotten"
            end
        end
        return nil
    end,
    function(part)
        -- Amulet of the White King
        if not part:IsA("UnionOperation") then return nil end
        if tostring(part.Color) ~= tostring(Color3.new(248/255, 248/255, 248/255)) then return nil end
        if part.Material ~= Enum.Material.Neon then return nil end
        local size = part.Size
        if math.abs(size.X - 0.195) > 0.01 or math.abs(size.Y - 1.811) > 0.01 or math.abs(size.Z - 1.04) > 0.01 then
            return nil
        end
        local clickPart = part:FindFirstChildOfClass("Part")
        if not (clickPart and clickPart.Transparency == 1) then return nil end
        for _, child in ipairs(part:GetChildren()) do
            if child:IsA("PointLight") then
                return "Amulet of the White King"
            end
        end
        return nil
    end,
    function(part)
        -- Nightstone
        if not part:IsA("UnionOperation") then return nil end
        if tostring(part.Color) ~= tostring(Color3.new(29/255,46/255,58/255)) then return nil end
        if part.Material ~= Enum.Material.Neon then return nil end
        local size = part.Size
        if math.abs(size.X - 0.4437) > 0.01 or math.abs(size.Y - 0.4436) > 0.01 or math.abs(size.Z - 0.4333) > 0.01 then
            return nil
        end
        local clickPart = part:FindFirstChildOfClass("Part")
        if not (clickPart and clickPart.Transparency == 1) then return nil end
        -- Nightstone não tem filhos especiais como PointLight ou ParticleEmitter
        return "Nightstone"
    end,
    function(part)
        -- ??? (orb roxo)
        if not part:IsA("Part") then return nil end
        if tostring(part.Color) ~= tostring(Color3.new(89/255,2/15,89/255)) then return nil end
        if part.Transparency ~= 1 then return nil end
        local size = part.Size
        if math.abs(size.X - 0.17486) > 0.01 or math.abs(size.Y - 0.17486) > 0.01 or math.abs(size.Z - 0.17486) > 0.01 then
            return nil
        end
        local clickPart = part:FindFirstChildOfClass("Part")
        if not (clickPart and clickPart.Transparency == 1) then return nil end
        local hasOrbParticle = false
        local hasPointLight = false
        local hasSphereMesh = false
        for _, child in ipairs(part:GetChildren()) do
            if child:IsA("ParticleEmitter") and child.Name == "OrbParticle" then
                hasOrbParticle = true
            elseif child:IsA("PointLight") then
                hasPointLight = true
            elseif child:IsA("SpecialMesh") and child.MeshType == Enum.MeshType.Sphere then
                hasSphereMesh = true
            end
        end
        if hasOrbParticle and hasPointLight and hasSphereMesh then
            return "???"
        end
        return nil
    end,
    function(part)
        -- Phoenix Down
        if not part:IsA("Part") then return nil end
        if tostring(part.Color) ~= tostring(Color3.new(1,4/5,0)) then return nil end
        if part.Transparency ~= 1 then return nil end
        local size = part.Size
        if math.abs(size.X - 0.444) > 0.01 or math.abs(size.Y - 0.444) > 0.01 or math.abs(size.Z - 0.433) > 0.01 then
            return nil
        end
        local clickPart = part:FindFirstChildOfClass("Part")
        if not (clickPart and clickPart.Transparency == 1) then return nil end
        -- Checa se tem Attachment com ParticleEmitter de textura específica
        local hasPhoenixParticle = false
        for _, child in ipairs(part:GetChildren()) do
            if child:IsA("Attachment") then
                for _, sub in ipairs(child:GetChildren()) do
                    if sub:IsA("ParticleEmitter") and tostring(sub.Texture) == "rbxassetid://1536547385" then
                        hasPhoenixParticle = true
                    end
                end
            end
        end
        if hasPhoenixParticle then
            return "Phoenix Down"
        end
        return nil
    end,
    -- Adicione mais matchers conforme necessário
}

local function getTrinketNameByMeshId(part)
    -- 0. Matchers para trinkets especiais
    for _, matcher in ipairs(SPECIAL_TRINKET_MATCHERS) do
        local name = matcher(part)
        if name then return name end
    end
    -- 1. MeshPart direto
    if part:IsA("MeshPart") and part.MeshId then
        local meshId = tostring(part.MeshId):gsub("%%20", ""):gsub("%s+", "")
        if MESH_ID_MAP[meshId] then
            return MESH_ID_MAP[meshId]
        else
            return meshId
        end
    end
    -- 2. SpecialMesh
    local specialMesh = part:FindFirstChildWhichIsA("SpecialMesh")
    if specialMesh and specialMesh.MeshId then
        local meshId = tostring(specialMesh.MeshId):gsub("%%20", ""):gsub("%s+", "")
        if MESH_ID_MAP[meshId] then
            return MESH_ID_MAP[meshId]
        else
            return meshId
        end
    end
    -- 3. Mesh
    local mesh = part:FindFirstChildWhichIsA("Mesh")
    if mesh and mesh.MeshId then
        local meshId = tostring(mesh.MeshId):gsub("%%20", ""):gsub("%s+", "")
        if MESH_ID_MAP[meshId] then
            return MESH_ID_MAP[meshId]
        else
            return meshId
        end
    end
    -- 4. Fallback: sempre 'Unknown'
    return "Unknown"
end

function TrinketESP.new()
    local self = setmetatable({}, TrinketESP)
    self.espBillboards = {}
    self._connMgr = ConnectionManager.new()
    return self
end

function TrinketESP:findTrinkets()
    local trinketFolder = Workspace
    if not trinketFolder then return {} end
    local trinkets = {}
    for _, obj in ipairs(trinketFolder:GetChildren()) do
        if obj:IsA("BasePart") then
            local idValue = obj:FindFirstChild("ID")
            if idValue and idValue:IsA("StringValue") then
                table.insert(trinkets, obj)
            end
        end
    end
    return trinkets
end

function TrinketESP:createBillboard(trinket)
    if self.espBillboards[trinket] then return end

    local billboard = Instance.new("BillboardGui")
    billboard.Name = "TrinketESP"
    billboard.Adornee = trinket
    billboard.LightInfluence = 1
    billboard.Active = true
    billboard.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    billboard.ClipsDescendants = true
    billboard.AlwaysOnTop = true
    billboard.Size = UDim2.new(0, 100, 0, 100)
    billboard.Parent = trinket

    local label = Instance.new("TextLabel")
    label.FontSize = Enum.FontSize.Size14
    label.TextColor3 = Color3.new(157/255, 157/255, 157/255)
    label.BorderColor3 = Color3.new(0, 0, 0)
    local meshName = getTrinketNameByMeshId(trinket)
    label.Text = meshName
    label.TextStrokeTransparency = 0.5
    label.AnchorPoint = Vector2.new(0.5, 0.5)
    label.Font = Enum.Font.SourceSans
    label.BackgroundTransparency = 1
    label.Position = UDim2.new(0.5, 0, 0.5, 0)
    label.Size = UDim2.new(1, 0, 1, 0)
    label.TextSize = 14
    label.BorderSizePixel = 0
    label.BackgroundColor3 = Color3.new(1, 1, 1)
    label.Parent = billboard

    local scale = Instance.new("UIScale")
    scale.Parent = billboard

    self.espBillboards[trinket] = billboard
    -- Gerenciar conexões deste trinket
    if self._trinketConnMgrs[trinket] then
        self._trinketConnMgrs[trinket]:disconnectAll()
    end
    self._trinketConnMgrs[trinket] = ConnectionManager.new()
    local mgr = self._trinketConnMgrs[trinket]
    -- Adicione aqui conexões específicas do trinket, se houver
end

function TrinketESP:removeBillboard(trinket)
    if self.espBillboards[trinket] then
        self.espBillboards[trinket]:Destroy()
        self.espBillboards[trinket] = nil
    end
    if self._trinketConnMgrs[trinket] then
        self._trinketConnMgrs[trinket]:disconnectAll()
        self._trinketConnMgrs[trinket] = nil
    end
end

function TrinketESP:updateESP()
    local trinkets = self:findTrinkets()
    local trinketSet = {}
    for _, trinket in ipairs(trinkets) do
        trinketSet[trinket] = true
        self:createBillboard(trinket)
    end
    -- Remove billboards de trinkets que sumiram
    for trinket in pairs(self.espBillboards) do
        if not trinketSet[trinket] then
            self:removeBillboard(trinket)
        end
    end
end

function TrinketESP:enable()
    if self.enabled then return end
    self.enabled = true
    self:updateESP()
    self._connMgr:add(RunService.Heartbeat:Connect(function()
        self:updateESP()
    end))
end

function TrinketESP:disable()
    self.enabled = false
    self._connMgr:disconnectAll()
    for trinket in pairs(self.espBillboards) do
        self:removeBillboard(trinket)
    end
    for _, mgr in pairs(self._trinketConnMgrs) do
        mgr:disconnectAll()
    end
    self._trinketConnMgrs = {}
end

return TrinketESP 
