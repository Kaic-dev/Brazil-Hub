local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local ConnectionManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/Kaic-dev/Brazil-Hub/main/ConnectionManager"))()

-- Cache de constantes para evitar re-alocações
local MESH_IDS = {
    ["rbxassetid://5196551436"] = "Amulet",
    ["rbxassetid://5196577540"] = "Old Amulet",
    ["rbxassetid://5204003946"] = "Goblet",
    ["rbxassetid://5196782997"] = "Old Ring",
    ["rbxassetid://5196776695"] = "Ring",
    ["rbxassetid://5204453430"] = "Scroll",
    ["rbxassetid://2877143560"] = "Ruby",
    ["rbxassetid://2877143592"] = "Sapphire",
    ["rbxassetid://2877143624"] = "Emerald",
    ["rbxassetid://2520762076"] = "Howler Friend"
}

local PHOENIX_TEXTURE = "rbxassetid://1536547385"
local BILLBOARD_SIZE = UDim2.new(0, 100, 0, 100)

-- Cache de enums para evitar lookups repetidos
local MATERIAL_SLATE = Enum.Material.Slate
local MATERIAL_NEON = Enum.Material.Neon
local MESHTYPE_SPHERE = Enum.MeshType.Sphere
local ZBEHAVIOR_SIBLING = Enum.ZIndexBehavior.Sibling
local FONT_SOURCESANS = Enum.Font.SourceSans

-- Cache de funções frequentemente usadas
local tostring = tostring
local pairs = pairs
local setmetatable = setmetatable
local Vector2_new = Vector2.new
local UDim2_new = UDim2.new
local Color3_new = Color3.new
local Instance_new = Instance.new

-- Função otimizada para limpar mesh IDs
local function cleanMeshId(id)
    local str = tostring(id)
    str = str:gsub("%%20", "")
    return str:gsub("%s+", "")
end

-- Função otimizada para verificar trinkets usando cache de verificações
local trinketCache = {}
local function isTrinket(obj)
    local objType = obj.ClassName
    -- Cache hit check primeiro
    if trinketCache[obj] ~= nil then
        return trinketCache[obj]
    end
    
    -- Verificação otimizada: só verifica se é Part/MeshPart primeiro
    if objType ~= "Part" and objType ~= "MeshPart" then
        trinketCache[obj] = false
        return false
    end
    
    local hasID = obj:FindFirstChild("ID") ~= nil
    trinketCache[obj] = hasID
    return hasID
end

-- Função otimizada para obter nome do trinket
local function getTrinketName(part)
    local material = part.Material
    
    -- Verificações mais rápidas primeiro (material checks)
    if material == MATERIAL_SLATE and part:FindFirstChildOfClass("ParticleEmitter") then
        return "Idol of the Forgotten"
    end
    
    if material == MATERIAL_NEON then
        return part:FindFirstChildOfClass("PointLight") and "Amulet of the White King" or "Nightstone"
    end
    
    if part.Transparency == 1 then
        local hasOrb, hasLight, hasSphere = false, false, false
        local children = part:GetChildren()
        
        -- Loop otimizado com early break conditions
        for i = 1, #children do
            local child = children[i]
            local childType = child.ClassName
            
            if childType == "ParticleEmitter" and child.Name == "OrbParticle" then
                hasOrb = true
            elseif childType == "PointLight" then
                hasLight = true
            elseif childType == "SpecialMesh" and child.MeshType == MESHTYPE_SPHERE then
                hasSphere = true
            elseif childType == "Attachment" then
                -- Verificação otimizada para Phoenix Down
                local attachChildren = child:GetChildren()
                for j = 1, #attachChildren do
                    local subChild = attachChildren[j]
                    if subChild.ClassName == "ParticleEmitter" and tostring(subChild.Texture) == PHOENIX_TEXTURE then
                        return "Phoenix Down"
                    end
                end
            end
            
            -- Early break se já encontrou tudo necessário
            if hasOrb and hasLight and hasSphere then
                break
            end
        end
        
        if hasOrb and hasLight and hasSphere then
            return "???"
        end
    end
    
    -- Verificação otimizada de mesh ID
    local meshId
    if part:IsA("MeshPart") then
        meshId = part.MeshId
    else
        local mesh = part:FindFirstChildWhichIsA("SpecialMesh") or part:FindFirstChildWhichIsA("Mesh")
        meshId = mesh and mesh.MeshId
    end
    
    if meshId and meshId ~= "" then
        return MESH_IDS[cleanMeshId(meshId)] or meshId
    else
        return "Unknown"
    end
end

local TrinketESP = {}
TrinketESP.__index = TrinketESP

function TrinketESP.new()
    return setmetatable({
        espBillboards = {},
        _connectionManager = ConnectionManager.new(),
        enabled = false,
        -- Sistema de fila para processamento assíncrono
        _pendingTrinkets = {},
        _processingQueue = false,
        -- Cache para evitar re-verificações
        _processedObjects = {}
    }, TrinketESP)
end

-- Função otimizada para criar billboard com menos alocações
function TrinketESP:createBillboard(trinket, trinketName)
    if self.espBillboards[trinket] then return end

    local billboard = Instance_new("BillboardGui")
    billboard.Name = "TrinketESP"
    billboard.Adornee = trinket
    billboard.LightInfluence = 1
    billboard.ZIndexBehavior = ZBEHAVIOR_SIBLING
    billboard.AlwaysOnTop = true
    billboard.Size = BILLBOARD_SIZE
    billboard.Parent = trinket

    local label = Instance_new("TextLabel")
    label.Text = trinketName
    label.TextColor3 = Color3_new(0.615, 0.615, 0.615)
    label.TextStrokeTransparency = 0.5
    label.Font = FONT_SOURCESANS
    label.TextSize = 14
    label.BackgroundTransparency = 1
    label.BorderSizePixel = 0
    label.Size = UDim2_new(1, 0, 1, 0)
    label.Position = UDim2_new(0.5, 0, 0.5, 0)
    label.AnchorPoint = Vector2_new(0.5, 0.5)
    label.Parent = billboard

    self.espBillboards[trinket] = billboard
end

function TrinketESP:removeBillboard(trinket)
    local billboard = self.espBillboards[trinket]
    if billboard then
        billboard:Destroy()
        self.espBillboards[trinket] = nil
    end
    
    -- Limpar cache relacionado
    trinketCache[trinket] = nil
    self._processedObjects[trinket] = nil
end

-- SOLUÇÃO 1: Sistema de fila assíncrona
function TrinketESP:processQueue()
    if self._processingQueue or #self._pendingTrinkets == 0 then return end
    
    self._processingQueue = true
    
    -- Processa até 5 trinkets por frame para evitar lag
    local maxPerFrame = 5
    local processed = 0
    
    while #self._pendingTrinkets > 0 and processed < maxPerFrame do
        local trinket = table.remove(self._pendingTrinkets, 1)
        
        -- Verificar se o trinket ainda é válido
        if trinket and trinket.Parent and not self._processedObjects[trinket] then
            self._processedObjects[trinket] = true
            local trinketName = getTrinketName(trinket)
            self:createBillboard(trinket, trinketName)
        end
        
        processed = processed + 1
    end
    
    self._processingQueue = false
    
    -- Se ainda há trinkets na fila, agenda próximo processamento
    if #self._pendingTrinkets > 0 then
        RunService.Heartbeat:Wait()
        self:processQueue()
    end
end

-- SOLUÇÃO 2: Detecção imediata com processamento assíncrono
function TrinketESP:onChildAdded(obj)
    if not self.enabled then return end
    
    -- Verificação imediata sem throttling
    if not isTrinket(obj) or self._processedObjects[obj] then 
        return 
    end
    
    -- Adiciona à fila para processamento assíncrono
    table.insert(self._pendingTrinkets, obj)
    
    -- Inicia processamento se não está rodando
    if not self._processingQueue then
        self:processQueue()
    end
end

function TrinketESP:onChildRemoved(obj)
    if not self.enabled or not self.espBillboards[obj] then return end
    
    self:removeBillboard(obj)
    
    -- Remove da fila pendente se ainda estiver lá
    for i = #self._pendingTrinkets, 1, -1 do
        if self._pendingTrinkets[i] == obj then
            table.remove(self._pendingTrinkets, i)
            break
        end
    end
end

-- SOLUÇÃO 3: Scan inicial otimizado em lotes
function TrinketESP:scanExistingTrinkets()
    local workspaceChildren = Workspace:GetChildren()
    local trinkets = {}
    
    -- Primeiro pass: identifica todos os trinkets
    for i = 1, #workspaceChildren do
        local obj = workspaceChildren[i]
        if isTrinket(obj) and not self._processedObjects[obj] then
            table.insert(trinkets, obj)
        end
    end
    
    -- Segundo pass: processa em lotes assíncronos
    for i = 1, #trinkets do
        table.insert(self._pendingTrinkets, trinkets[i])
    end
    
    if #self._pendingTrinkets > 0 then
        self:processQueue()
    end
end

function TrinketESP:enable()
    if self.enabled then return end
    
    self.enabled = true
    
    -- Scan inicial otimizado
    self:scanExistingTrinkets()
    
    -- Conexões sem throttling - detecção imediata
    self._connectionManager:add(Workspace.ChildAdded:Connect(function(obj)
        self:onChildAdded(obj)
    end))
    
    self._connectionManager:add(Workspace.ChildRemoved:Connect(function(obj)
        self:onChildRemoved(obj)
    end))
end

function TrinketESP:disable()
    self.enabled = false
    self._connectionManager:disconnectAll()
    
    -- Limpeza otimizada
    for trinket in pairs(self.espBillboards) do
        self:removeBillboard(trinket)
    end
    
    -- Limpar caches e fila
    trinketCache = {}
    self._processedObjects = {}
    self._pendingTrinkets = {}
    self._processingQueue = false
end

function TrinketESP:destroy()
    self:disable()
    self._connectionManager = nil
    self.espBillboards = nil
    self._processedObjects = nil
    self._pendingTrinkets = nil
end

return TrinketESP
